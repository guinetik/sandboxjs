<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Security-Policy" content="{{DYNAMIC_CSP}}">
  <title>Sandbox</title>
  {{LIBRARY_SCRIPTS}}
  <style>
    html,
    body {
      margin: 0;
      padding: 12px;
      font: 14px/1.4 -apple-system, system-ui, Segoe UI, Roboto
    }

    body {
      background: #fff;
      color: #111
    }
  </style>
</head>

<body>
  <script>
    //# sourceURL=sandbox-execution.js
    // Block Vite client injection
    if (window.parent !== window) {
      // Override any WebSocket connections
      window.WebSocket = function() { throw new Error('WebSocket blocked in sandbox'); };
      window.EventSource = function() { throw new Error('EventSource blocked in sandbox'); };
    }

    (function () {
      var SECRET = "{{SECRET}}";
      var serializeArg = function(arg) {
        try {
          // Handle primitive types and null/undefined
          if (arg === null || arg === undefined || typeof arg !== 'object') {
            return arg;
          }

          // For all objects, try JSON.stringify first
          return JSON.stringify(arg, function(key, value) {
            // Handle functions
            if (typeof value === 'function') {
              return '[Function: ' + (value.name || 'anonymous') + ']';
            }
            // Handle DOM elements
            if (value && value.nodeType) {
              return '[DOM Element: ' + value.tagName + (value.id ? '#' + value.id : '') + ']';
            }
            return value;
          });
        } catch (e) {
          // Fallback for circular references or other serialization issues
          return '[Object: ' + Object.prototype.toString.call(arg) + ']';
        }
      };

      var send = function (type) {
        var args = Array.prototype.slice.call(arguments, 1);
        var serializedArgs = args.map(serializeArg);
        try { parent.postMessage({ __sandbox: true, secret: SECRET, type: type, args: serializedArgs }, "*"); } catch (e) { }
      };

      ["log", "info", "warn", "error"].forEach ? ["log", "info", "warn", "error"].forEach(function (m) {
        var original = console[m].bind(console);
        console[m] = function () { send.apply(null, [m].concat([].slice.call(arguments))); try { original.apply(console, arguments); } catch (_) { } };
      }) : null;
      // Mark where user code starts for line number calculation
      var USER_CODE_START = true;

      addEventListener("error", function (e) {
        // Prevent browser console logging
        e.preventDefault();

        var errorMsg = '';
        if (e.error) {
          var err = e.error;
          errorMsg = (err.name || 'Error') + ': ' + (err.message || 'Unknown error');

          // Parse the stack to get line numbers
          if (err.stack) {
            var lines = err.stack.split('\n');

            // Look for line numbers in the stack trace
            for (var i = 0; i < lines.length && i < 3; i++) {
              var line = lines[i];

              // Match line:column pattern
              var match = line.match(/:(\d+):(\d+)/);
              if (match) {
                var absoluteLineNo = parseInt(match[1]);
                var colNo = match[2];

                var lineNo = parseInt(match[1]);
                var colNo = match[2];
                var lineUserCodeStarts = 150; // Same offset as in try-catch

                // Extract function name if present
                var fnMatch = line.match(/^(\w+)@|at\s+(\w+)/);
                var fnName = fnMatch ? (fnMatch[1] || fnMatch[2]) : null;

                var adjustedLineNo = lineNo - lineUserCodeStarts;
                if (adjustedLineNo > 0) {
                  if (fnName && fnName !== 'eval') {
                    errorMsg += '\n    at ' + fnName + ' (line ' + adjustedLineNo + ', column ' + colNo + ')';
                  } else {
                    errorMsg += '\n    at line ' + adjustedLineNo + ', column ' + colNo;
                  }
                }
              }
            }
          } else if (e.lineno) {
            // Fallback to event line/column
            errorMsg += '\n    at line ' + e.lineno + ', column ' + e.colno;
          }
        } else {
          // No error object, use basic info
          errorMsg = e.message || 'Unknown error';
          if (e.lineno) {
            errorMsg += '\n    at line ' + e.lineno + ', column ' + e.colno;
          }
        }

        send("error", errorMsg);
        return true;
      });
      addEventListener("unhandledrejection", function (e) {
        e.preventDefault();
        var r = e.reason;
        var errorMsg = "Unhandled Promise Rejection: ";
        if (r instanceof Error) {
          errorMsg += (r.name || 'Error') + ': ' + (r.message || 'Unknown');
          if (r.stack) {
            // Add first few lines of stack trace
            var lines = r.stack.split('\n').slice(1, 3);
            lines.forEach(function(line) {
              if (line.trim()) errorMsg += '\n    ' + line.trim();
            });
          }
        } else {
          errorMsg += String(r);
        }
        send("error", errorMsg);
        return true;
      });
      try {
        {{USER_CODE}}
      } catch (err) {
        // Send error directly instead of using console.error
        var errorMsg = (err.name || 'Error') + ': ' + (err.message || 'Unknown error');
        var lineUserCodeStarts = 152;
        // Parse the stack to get line numbers
        if (err.stack) {
          var lines = err.stack.split('\n');

          // Look for line numbers in the stack trace
          for (var i = 0; i < lines.length && i < 3; i++) {
            var line = lines[i];

            // Match various stack trace formats
            var match = line.match(/:(\d+):(\d+)/);
            if (match) {
              var absoluteLineNo = parseInt(match[1]);
              var colNo = match[2];

              // Show raw line numbers for now
              var lineNo = match[1];
              var colNo = match[2];

              // Extract function name if present
              var fnMatch = line.match(/^(\w+)@|at\s+(\w+)/);
              var fnName = fnMatch ? (fnMatch[1] || fnMatch[2]) : null;

              if (fnName && fnName !== 'eval') {
                errorMsg += '\n    at ' + fnName + ' (line ' + (lineNo - lineUserCodeStarts) + ', column ' + colNo + ')';
              } else {
                errorMsg += '\n    at line ' +  (lineNo - lineUserCodeStarts) + ', column ' + colNo;
              }
            }
          }
        }

        send("error", errorMsg);
      } finally {
        setTimeout(function () {
          send("done");
        }, 0);
      }
    })();
  </script>
</body>

</html>